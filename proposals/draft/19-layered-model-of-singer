# SIP #`<TBD>` - Layered Model of Singer

_This document follows the [Singer Improvement Proposal (SIP) process](./draft/PR21%20-%20Proposal%20Documentation%20and%20Review.md)_

## Proposal Status

| header | header |
| ------ | ------ |
| State | Draft |
| Issue Link | [#19](https://github.com/MeltanoLabs/Singer-Working-Group/issues/19) |
| Created | 2022-01-13 |
| Updated | 2022-01-13 |

-----------------------

## I. Proposal Summary

### TL;DR Overview

The Layered Model of Singer is a mechanism for organizing the mass collection of libraries, patterns, and practices that organizations using Singer and providing a means of discussing how these best practices fit into the overall ecosystem.

In addition to categorization, its second goal is to enable structured conversation about how to move a practice between levels. For example, pulling a concept from a library and generalizing it as a widespread standard.

### What specific change do you propose to make?

This change is a document for the Singer Working Group as a meta-specification to provide guidelines for discussing proposed features to categorize a proposal and its components for discussion.

## Motivation

Singer is a lot of things aside from a JSON-line based data exchange protocol. It is a collection of tools, best practices, reserved metadata keywords, standard command-line arguments, web applications, orchestration tooling/practices, and more. A part of how this could evolve in this way is from the open-endedness of the original spec. Data extraction use cases vary by source, by runtime environment, by orchestration mechanism, etc. and those use cases generally cannot be anticipated up front.

The motivation here is to help keep that simplicity by defining levels from a most generic level (Spec) to a most specific level (Framework/Application).

### What problem does it solve?

The problem it is solving is having a consistent language to discuss features and changes proposed in the Singer Working Group so that all participants can be sure that they are talking about the same thing.

### Why is it needed?

Having this sort of language to categorize pieces of a proposed change into varying degrees of specificity will allow proposals to be refined and keep use-case specific mechanisms out of lower levels.

For example, if use-case specific details make their way into the over-the-wire JSON line Spec, this would end up pushing the protocol to become more complicated to write software that reads and writes (more conditions to handle), thus leading to a spread of logical bloat in those implementing the protocol.

-----------------------

## II. Proposal Details

...(Detailed information here)...
## The Layered Model of Singer

Looking at Singer, there are a lot of design choices baked in around a core value of simplicity. The reasoning for this has always been to give developers the freedom and flexibility to make it what they want, since all data sources are vastly different, and one cannot effectively design for all future cases in the ELT space.

As we discuss evolving Singer as a whole and as a community, it will be important to take care to not lose the core value of simplicity that has allowed the space for best practices to be invented like those encoded in the current existing frameworks/libraries.

Approaching the stack as a layered model can give us a means of aligning where an idea fits, and a tool iterate organically to "upgrade" concepts from a framework feature to a codified standard to a spec change if it makes sense.

### Layer 1: Specification
This is the current specification as it stands, some principles of features here:
- Language agnostic and implementation independent
- Focus on the std-out portions of using Singer (serialization format, message types, required keys for messages, etc.)

### Layer 2: Standards and Best Practices
These are being tracked in #10, but as far as the initial design decisions of Singer go, this conceptually includes things like Command-Line Arguments, Catalog, Metadata Keys/Custom Metadata, Standard State Keys, etc.

Some principles here:
- These are also language agnostic and implementation independent
- They help standardize the nitty-gritty to make writing frameworks and libraries more easy
- They strive to make code more portable, readable, and usable for users and devs alike.

[TODO: Split into required and optional]

### Layer 3: Libraries and Frameworks
This is where we get into the language specific stuff. Libraries like `singer-python` and/or `singer-clojure` or frameworks like the MeltanoSDK take the standards plus best practices and encode them in a way that makes sense for the patterns of each language. This is also a good place to be a test bed for things that might become standards.

Principles:
- Language specific
- Generic use cases
- These influence the way that code is written for their specific language

### Layer 4: Tooling/Orchestration/UX/Infrastructure
I'm not quite sure about this one, but these are things that don't seem to fit in the other layers, and kind of make up an analog to the "Application Layer" of the OSI layered model. This layer is included to be a spot to hold things that are in use on a specific industry, use case, deployment method, etc., but not quite ready to be standardized.

[Aside:] This layer could use the most work, but it seemed worth including here. My gut says that it's likely harder to standardize these kinds of things, since it'll be where our orgs' respective product offerings fall into a lot of the time, and with that comes IP concerns, specifics for our target users (e.g., technical vs. non-technical), a specific slice of the industry, and/or a more narrow set of use cases. That said, tools like `singer-discover` would also fall here, and fit into a standardization conversation more easily.

-----------------------

## III. Additional Information

<!-- Note: Author may delete any headers in this section which are not relevant. -->

### Which layer(s) of the Singer ecosystem does this proposal directly touch?

Select all that apply:

- [ ] Singer Specification - required capabilities and behaviors
- [ ] Singer Specification - optional capabilities and behaviors
- [ ] Singer best practices and other guidance
- [x] **Singer Working Group - practices and procedures**
- [ ] Singer documentation (Other)

### Are there any downsides to this change?

...

### Is the change backwards compatible?

...

### Other Considerations

...

### How are Singer developers affected by the change (if applicable)?

...

### How are Singer users affected by the change? (if applicable)?

...

### Prototype Implementations

...(if applicable)...

### Future Plans

...(if applicable)...

### Excluded Alternatives

...(if applicable)...

### Acknowledgements

...(if applicable)...

### What defines this SIP as "done"?

...
